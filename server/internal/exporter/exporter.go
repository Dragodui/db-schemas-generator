package exporter

import (
	"fmt"
	"strings"

	"github.com/Dragodui/db-schemas-generator/internal/model"
)

type ExportFormat string

const (
	FormatMySQL    ExportFormat = "mysql"
	FormatPostgres ExportFormat = "postgres"
	FormatMongo    ExportFormat = "mongo"
)

func Export(schema model.SchemaData, format ExportFormat) (string, error) {
	switch format {
	case FormatMySQL:
		return exportMySQL(schema)
	case FormatPostgres:
		return exportPostgres(schema)
	case FormatMongo:
		return exportMongo(schema)
	default:
		return "", fmt.Errorf("unsupported format: %s", format)
	}
}

func exportMySQL(schema model.SchemaData) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- MySQL Schema Export\n")
	sb.WriteString("-- Generated by DB Schema Generator\n\n")

	for _, table := range schema.Tables {
		sb.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", table.Name))

		var columns []string
		var primaryKeys []string

		for _, col := range table.Columns {
			colDef := fmt.Sprintf("  `%s` %s", col.Name, mapTypeToMySQL(col.Type))

			if col.NotNull {
				colDef += " NOT NULL"
			}

			if col.AutoIncrement {
				colDef += " AUTO_INCREMENT"
			}

			if col.Unique && !col.PrimaryKey {
				colDef += " UNIQUE"
			}

			if col.Default != nil {
				colDef += fmt.Sprintf(" DEFAULT %s", formatDefaultMySQL(*col.Default, col.Type))
			}

			if len(col.EnumValues) > 0 && strings.ToUpper(col.Type) == "ENUM" {
				enumVals := make([]string, len(col.EnumValues))
				for i, v := range col.EnumValues {
					enumVals[i] = fmt.Sprintf("'%s'", v)
				}
				colDef = fmt.Sprintf("  `%s` ENUM(%s)", col.Name, strings.Join(enumVals, ", "))
				if col.NotNull {
					colDef += " NOT NULL"
				}
			}

			columns = append(columns, colDef)

			if col.PrimaryKey {
				primaryKeys = append(primaryKeys, fmt.Sprintf("`%s`", col.Name))
			}
		}

		if len(primaryKeys) > 0 {
			columns = append(columns, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(primaryKeys, ", ")))
		}

		for _, fk := range table.ForeignKeys {
			fkDef := fmt.Sprintf("  FOREIGN KEY (`%s`) REFERENCES `%s`(`%s`)",
				fk.Column, fk.References.Table, fk.References.Column)
			if fk.OnDelete != "" {
				fkDef += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
			}
			if fk.OnUpdate != "" {
				fkDef += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
			}
			columns = append(columns, fkDef)
		}

		sb.WriteString(strings.Join(columns, ",\n"))

		engine := "InnoDB"
		if table.Engine != "" {
			engine = table.Engine
		}
		sb.WriteString(fmt.Sprintf("\n) ENGINE=%s DEFAULT CHARSET=utf8mb4;\n\n", engine))
	}

	return sb.String(), nil
}

func exportPostgres(schema model.SchemaData) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- PostgreSQL Schema Export\n")
	sb.WriteString("-- Generated by DB Schema Generator\n\n")

	// First, create ENUM types if needed
	for _, table := range schema.Tables {
		for _, col := range table.Columns {
			if strings.ToUpper(col.Type) == "ENUM" && len(col.EnumValues) > 0 {
				enumName := fmt.Sprintf("%s_%s_enum", table.Name, col.Name)
				enumVals := make([]string, len(col.EnumValues))
				for i, v := range col.EnumValues {
					enumVals[i] = fmt.Sprintf("'%s'", v)
				}
				sb.WriteString(fmt.Sprintf("CREATE TYPE %s AS ENUM (%s);\n\n", enumName, strings.Join(enumVals, ", ")))
			}
		}
	}

	for _, table := range schema.Tables {
		sb.WriteString(fmt.Sprintf("CREATE TABLE \"%s\" (\n", table.Name))

		var columns []string
		var primaryKeys []string

		for _, col := range table.Columns {
			pgType := mapTypeToPostgres(col.Type)

			if col.AutoIncrement {
				if strings.Contains(strings.ToUpper(col.Type), "BIG") {
					pgType = "BIGSERIAL"
				} else {
					pgType = "SERIAL"
				}
			}

			if strings.ToUpper(col.Type) == "ENUM" && len(col.EnumValues) > 0 {
				pgType = fmt.Sprintf("%s_%s_enum", table.Name, col.Name)
			}

			colDef := fmt.Sprintf("  \"%s\" %s", col.Name, pgType)

			if col.NotNull && !col.AutoIncrement {
				colDef += " NOT NULL"
			}

			if col.Unique && !col.PrimaryKey {
				colDef += " UNIQUE"
			}

			if col.Default != nil && !col.AutoIncrement {
				colDef += fmt.Sprintf(" DEFAULT %s", formatDefaultPostgres(*col.Default, col.Type))
			}

			columns = append(columns, colDef)

			if col.PrimaryKey {
				primaryKeys = append(primaryKeys, fmt.Sprintf("\"%s\"", col.Name))
			}
		}

		if len(primaryKeys) > 0 {
			columns = append(columns, fmt.Sprintf("  PRIMARY KEY (%s)", strings.Join(primaryKeys, ", ")))
		}

		for _, fk := range table.ForeignKeys {
			fkDef := fmt.Sprintf("  FOREIGN KEY (\"%s\") REFERENCES \"%s\"(\"%s\")",
				fk.Column, fk.References.Table, fk.References.Column)
			if fk.OnDelete != "" {
				fkDef += fmt.Sprintf(" ON DELETE %s", fk.OnDelete)
			}
			if fk.OnUpdate != "" {
				fkDef += fmt.Sprintf(" ON UPDATE %s", fk.OnUpdate)
			}
			columns = append(columns, fkDef)
		}

		sb.WriteString(strings.Join(columns, ",\n"))
		sb.WriteString("\n);\n\n")
	}

	return sb.String(), nil
}

func exportMongo(schema model.SchemaData) (string, error) {
	var sb strings.Builder

	sb.WriteString("// MongoDB Schema Export (Validator)\n")
	sb.WriteString("// Generated by DB Schema Generator\n\n")

	for _, table := range schema.Tables {
		sb.WriteString(fmt.Sprintf("db.createCollection(\"%s\", {\n", table.Name))
		sb.WriteString("  validator: {\n")
		sb.WriteString("    $jsonSchema: {\n")
		sb.WriteString("      bsonType: \"object\",\n")

		var required []string
		for _, col := range table.Columns {
			if col.NotNull || col.PrimaryKey {
				required = append(required, fmt.Sprintf("\"%s\"", col.Name))
			}
		}

		if len(required) > 0 {
			sb.WriteString(fmt.Sprintf("      required: [%s],\n", strings.Join(required, ", ")))
		}

		sb.WriteString("      properties: {\n")

		var props []string
		for _, col := range table.Columns {
			prop := fmt.Sprintf("        \"%s\": {\n", col.Name)
			prop += fmt.Sprintf("          bsonType: \"%s\"", mapTypeToMongo(col.Type))

			if len(col.EnumValues) > 0 {
				enumVals := make([]string, len(col.EnumValues))
				for i, v := range col.EnumValues {
					enumVals[i] = fmt.Sprintf("\"%s\"", v)
				}
				prop += fmt.Sprintf(",\n          enum: [%s]", strings.Join(enumVals, ", "))
			}

			prop += "\n        }"
			props = append(props, prop)
		}

		sb.WriteString(strings.Join(props, ",\n"))
		sb.WriteString("\n      }\n")
		sb.WriteString("    }\n")
		sb.WriteString("  }\n")
		sb.WriteString("});\n\n")

		// Create indexes for foreign keys
		for _, fk := range table.ForeignKeys {
			sb.WriteString(fmt.Sprintf("db.%s.createIndex({ \"%s\": 1 });\n", table.Name, fk.Column))
		}

		// Create unique indexes
		for _, col := range table.Columns {
			if col.Unique || col.PrimaryKey {
				sb.WriteString(fmt.Sprintf("db.%s.createIndex({ \"%s\": 1 }, { unique: true });\n", table.Name, col.Name))
			}
		}

		sb.WriteString("\n")
	}

	return sb.String(), nil
}

func mapTypeToMySQL(t string) string {
	upper := strings.ToUpper(t)
	switch upper {
	case "INTEGER", "INT":
		return "INT"
	case "SERIAL":
		return "INT"
	case "BIGSERIAL":
		return "BIGINT"
	case "DOUBLE PRECISION":
		return "DOUBLE"
	case "BOOLEAN":
		return "TINYINT(1)"
	case "TIMESTAMPTZ":
		return "TIMESTAMP"
	case "JSONB":
		return "JSON"
	case "UUID":
		return "CHAR(36)"
	default:
		return upper
	}
}

func mapTypeToPostgres(t string) string {
	upper := strings.ToUpper(t)
	switch upper {
	case "INT":
		return "INTEGER"
	case "TINYINT", "TINYINT(1)":
		return "BOOLEAN"
	case "DOUBLE":
		return "DOUBLE PRECISION"
	case "DATETIME":
		return "TIMESTAMP"
	case "LONGTEXT", "MEDIUMTEXT", "TINYTEXT":
		return "TEXT"
	case "LONGBLOB", "MEDIUMBLOB", "TINYBLOB", "BLOB":
		return "BYTEA"
	case "BINARY", "VARBINARY":
		return "BYTEA"
	default:
		return upper
	}
}

func mapTypeToMongo(t string) string {
	upper := strings.ToUpper(t)
	switch {
	case strings.Contains(upper, "INT") || upper == "SERIAL" || upper == "BIGSERIAL":
		if strings.Contains(upper, "BIG") {
			return "long"
		}
		return "int"
	case strings.Contains(upper, "FLOAT") || strings.Contains(upper, "DOUBLE") ||
		strings.Contains(upper, "DECIMAL") || strings.Contains(upper, "NUMERIC") || upper == "REAL":
		return "double"
	case strings.Contains(upper, "BOOL"):
		return "bool"
	case strings.Contains(upper, "DATE") || strings.Contains(upper, "TIME"):
		return "date"
	case upper == "JSON" || upper == "JSONB":
		return "object"
	case upper == "UUID":
		return "string"
	default:
		return "string"
	}
}

func formatDefaultMySQL(def string, colType string) string {
	upper := strings.ToUpper(def)
	if upper == "NULL" || upper == "CURRENT_TIMESTAMP" || upper == "NOW()" {
		return upper
	}
	if upper == "TRUE" {
		return "1"
	}
	if upper == "FALSE" {
		return "0"
	}
	// Check if numeric
	if _, err := fmt.Sscanf(def, "%f", new(float64)); err == nil {
		return def
	}
	return fmt.Sprintf("'%s'", def)
}

func formatDefaultPostgres(def string, colType string) string {
	upper := strings.ToUpper(def)
	if upper == "NULL" || upper == "NOW()" || upper == "CURRENT_TIMESTAMP" {
		return upper
	}
	if upper == "TRUE" || upper == "FALSE" {
		return upper
	}
	// Check if numeric
	if _, err := fmt.Sscanf(def, "%f", new(float64)); err == nil {
		return def
	}
	return fmt.Sprintf("'%s'", def)
}
